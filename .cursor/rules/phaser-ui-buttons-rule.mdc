# Phaser UI Buttons Rule

## Core Principle
All interactive UI buttons in the AstroHauler game MUST be implemented as Phaser buttons within Phaser scenes, NOT as React buttons. React should only handle non-interactive UI elements like score displays, text overlays, and informational content.

## Implementation Guidelines

### Phaser Button Implementation
- Use `this.add.image()` or `this.add.sprite()` for button visuals
- Implement `setInteractive()` for touch/click handling
- Use proper event listeners: `pointerdown`, `pointerup`, `pointerover`, `pointerout`
- Position buttons using Phaser's coordinate system
- Handle button states (normal, hover, pressed, disabled) within Phaser

### Button Positioning
- Use responsive positioning based on camera bounds: `this.cameras.main.width` and `this.cameras.main.height`
- Position relative to screen edges for consistent placement across devices
- Account for mobile touch zones and safe areas
- Use percentage-based positioning for scalability

### Button Styling
- Use texture atlases for button states when possible
- Implement visual feedback (scale, tint, alpha changes)
- Follow the game's art style and color palette
- Ensure buttons meet minimum touch target size (44px) on mobile

### Touch and Mobile Considerations
- Make buttons large enough for touch interaction
- Add appropriate padding around touch areas
- Handle both mouse and touch events
- Consider thumb-friendly positioning on mobile devices
- Implement proper button highlighting for accessibility

### Event Handling
- Use EventBus for communication between Phaser buttons and React components
- Keep button logic within the Phaser scene
- Emit events for state changes that React needs to know about
- Clean up event listeners when scenes are destroyed

### Examples

#### Basic Phaser Button
```typescript
// In a Phaser scene
const button = this.add.image(x, y, 'button-texture')
    .setInteractive()
    .on('pointerdown', () => {
        // Button pressed logic
        button.setScale(0.95); // Visual feedback
    })
    .on('pointerup', () => {
        // Button released logic
        button.setScale(1.0);
        this.handleButtonClick();
    })
    .on('pointerover', () => {
        // Hover state
        button.setTint(0xcccccc);
    })
    .on('pointerout', () => {
        // Normal state
        button.clearTint();
    });
```

#### Responsive Button Positioning
```typescript
// Position button relative to screen
const screenWidth = this.cameras.main.width;
const screenHeight = this.cameras.main.height;

const button = this.add.image(
    screenWidth * 0.9,  // 90% from left edge
    screenHeight * 0.1, // 10% from top edge
    'button-texture'
).setInteractive();
```

### What NOT to Do
- ❌ Do not create React buttons that overlay on top of the Phaser canvas
- ❌ Do not use HTML/CSS buttons for game interactions
- ❌ Do not mix React button events with Phaser game state
- ❌ Do not position buttons using CSS absolute positioning over the game

### What TO Do
- ✅ Create all interactive buttons within Phaser scenes
- ✅ Use Phaser's built-in interaction system
- ✅ Position buttons using Phaser's coordinate system
- ✅ Handle button events within the appropriate Phaser scene
- ✅ Use EventBus for cross-system communication when needed
- ✅ Implement proper visual feedback and accessibility features

## Scene-Specific Button Guidelines

### MainMenuScene
- All menu navigation buttons should be Phaser objects
- Position centrally or in a grid layout
- Use consistent styling across all menu buttons

### GameScene
- HUD buttons (pause, settings) should be positioned at screen edges
- Use semi-transparent backgrounds for better visibility
- Ensure buttons don't interfere with gameplay area

### CommandCenterScene
- Shop/upgrade buttons should be interactive Phaser objects
- Display button states clearly (affordable, unaffordable, owned)
- Use icons and text combined for clarity

## Testing Requirements
- Test button interactions on both desktop and mobile
- Verify button sizing meets accessibility guidelines
- Ensure buttons work with both mouse and touch input
- Test button positioning across different screen sizes and orientations

## Performance Considerations
- Reuse button textures where possible
- Use object pooling for frequently created/destroyed buttons
- Optimize button update loops to avoid performance issues
- Clean up button event listeners when scenes are destroyed